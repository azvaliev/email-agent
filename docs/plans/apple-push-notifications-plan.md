# Apple Push Notifications (Web Push) Implementation Plan

## Overview

Implement Web Push notifications to notify users on their iOS/Android devices when important emails arrive. Uses the standard Web Push Protocol with VAPID authentication, which works across all modern browsers including iOS Safari 16.4+.

```
Backend (PushForge) → Apple/Google Push Service → User's PWA (ServiceWorker) → Notification
```

**Key Requirement:** On iOS, Web Push only works when the app is installed as a PWA (added to home screen). We enforce PWA installation before allowing dashboard access.

---

## Architecture

| Component | Purpose |
|-----------|---------|
| **VAPID Keys** | Keypair for authenticating with push services (generated once) |
| **Service Worker** | Receives push events, displays notifications |
| **Push Subscription** | Per-device endpoint + keys stored in our DB |
| **PushForge** | Server-side library to build and send notifications |

### Flow: Subscription

```
1. User opens PWA (must be installed to home screen)
2. App detects standalone mode, shows "Enable Notifications" button
3. User clicks button → browser prompts for permission
4. If granted, call PushManager.subscribe() with our VAPID public key
5. Browser generates a unique keypair for this device and registers with push service
6. Browser returns a PushSubscription object containing:
   - endpoint: URL to the push service (e.g., https://web.push.apple.com/xxx)
   - keys.p256dh: Device's public key (for encrypting payloads)
   - keys.auth: Shared auth secret (for message authentication)
7. Frontend sends this subscription to our backend → stored in DB
```

**Why encryption keys?** Push payloads are encrypted end-to-end. The push service (Apple/Google) cannot read message contents. When we send a notification, we encrypt it using the device's `p256dh` public key and `auth` secret. Only that specific browser/device can decrypt it.

### Flow: Sending Notification

```
1. Gmail webhook fires (email received)
2. AI determines email is important
3. Backend looks up user's push subscriptions
4. For each subscription, build request with PushForge and send via fetch()
5. Push service delivers to device → service worker shows notification
```

---

## PWA Enforcement

### Detection

Detect standalone mode using media query + iOS-specific property:

```typescript
function isPWAInstalled(): boolean {
  const standaloneMedia = window.matchMedia('(display-mode: standalone)').matches;
  const iosStandalone = ((navigator as any)?.standalone ?? false) === true;
  return standaloneMedia || iosStandalone;
}
```

Create a `usePWAStatus()` hook using `useMemo` (value won't change during session). If not PWA, render an installation prompt instead of the dashboard.

---

## Database

### New Table: `push_subscription`

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| `id` | `text` | NOT NULL | Primary key (UUID) |
| `user_id` | `text` | NOT NULL | FK → user.id |
| `endpoint` | `text` | NOT NULL | Push service URL (unique per device) |
| `p256dh` | `text` | NOT NULL | Device's public key (browser-generated) |
| `auth` | `text` | NOT NULL | Device's auth secret (browser-generated) |
| `user_agent` | `text` | NULL | Device info (for display in settings) |
| `created_at` | `timestamptz` | NOT NULL | When subscription was created |

**Constraints:**
- `endpoint` is UNIQUE (one subscription per device)
- `user_id` FK → user.id ON DELETE CASCADE
- A user can have multiple subscriptions (phone, tablet, desktop)
- When a push fails with 410 Gone, delete the subscription

---

## VAPID Keys

Generate once per project using the PushForge CLI:

```bash
npx @pushforge/builder generate-vapid-keys
```

This outputs:
- **Public key** (base64url string) → `NEXT_PUBLIC_VAPID_PUBLIC_KEY`
- **Private key** (JWK object) → `VAPID_PRIVATE_JWK`

VAPID keys identify your server to push services. All users/devices use the same VAPID keys. The per-device encryption keys (`p256dh`, `auth`) are generated by the browser during subscription.

## Environment Variables

```bash
NEXT_PUBLIC_VAPID_PUBLIC_KEY=your_public_key_here
VAPID_PRIVATE_JWK='{"kty":"EC","crv":"P-256","x":"...","y":"...","d":"..."}'
VAPID_SUBJECT=mailto:your-email@example.com
```

- `NEXT_PUBLIC_VAPID_PUBLIC_KEY` - exposed to client (needed for subscription)
- `VAPID_PRIVATE_JWK` - server-only JSON Web Key (PushForge uses JWK format)
- `VAPID_SUBJECT` - contact info for push service operators to reach you if there's a problem (e.g., your server is sending malformed requests). Must be `mailto:` or `https://` URL. Apple is strict about validation.

---

## Dependencies

```bash
yarn add @pushforge/builder
```

Zero dependencies, TypeScript-first, works in Node.js/Deno/Bun/Cloudflare Workers.

---

## Key Implementation Details

### Sending a Push (Server-side)

Using [PushForge](https://github.com/draphy/pushforge/blob/master/packages/builder/README.md):

1. Call `buildPushHTTPRequest()` with:
   - Our VAPID private key (JWK format)
   - The device's subscription (endpoint + keys from DB)
   - The message payload (title, body, url, tag) and options (ttl, urgency)
2. This returns `{ endpoint, headers, body }` - a ready-to-send HTTP request
3. POST to the endpoint using `fetch()`
4. Handle response: 201 = success, 410 = subscription expired (delete from DB)

### Client-side Subscription Flow

See [MDN PushManager](https://developer.mozilla.org/en-US/docs/Web/API/PushManager):

**On app load (sync with server):**
1. Check browser support (`'PushManager' in window`)
2. Get service worker registration (`navigator.serviceWorker.ready`)
3. Call `pushManager.getSubscription()` to check existing subscription
4. If subscription exists → POST to server (upsert by `endpoint`)
5. If null → show "Enable Notifications" button

**When user enables notifications:**
1. Request permission (`Notification.requestPermission()`)
2. If granted → call `pushManager.subscribe()`, POST to server
3. If denied → show toast explaining some functionality will be limited (with action to retry if user changes mind)

Use shadcn [Sonner](https://ui.shadcn.com/docs/components/sonner) for the toast.

**Server upsert:** Use `endpoint` as the unique key. The `p256dh` and `auth` keys can rotate even if endpoint stays the same, so update them on conflict.

**Why sync on every load?** Handles edge cases where server deleted the subscription (after 410) but client still has it. Re-upserting keeps them in sync.

**Note:** The VAPID public key needs conversion from base64url to Uint8Array. Search for `urlBase64ToUint8Array` - this is a common helper.

### Service Worker

See [MDN Service Worker push event](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/push_event):

Handle two events in `public/sw.js`:
- `push` - parse the payload, call `self.registration.showNotification()`
- `notificationclick` - close notification, focus or open window with target URL

### Manifest

`public/manifest.json` must have `"display": "standalone"` for iOS push support.

---

## Implementation Order

### Phase 1: PWA Foundation
1. [ ] Update `manifest.json` with `"display": "standalone"` and icons
2. [ ] Create `use-pwa-status.ts` hook
3. [ ] Create `install-pwa-prompt.tsx` component
4. [ ] Add PWA gate to dashboard layout

### Phase 2: Push Infrastructure
5. [ ] Add VAPID env vars to `env.ts` and `.env.example`
6. [ ] Generate VAPID keys (`npx @pushforge/builder generate-vapid-keys`)
7. [ ] Install `@pushforge/builder`
8. [ ] Create database migration for `push_subscription`
9. [ ] Run migration and regenerate types

### Phase 3: Service Worker
10. [ ] Create `public/sw.js` with push and click handlers
11. [ ] Register service worker in app entry point

### Phase 4: Subscription Flow
12. [ ] Implement `src/lib/push/vapid.ts`
13. [ ] Implement `src/lib/push/client.ts` (browser-side)
14. [ ] Create `/api/push/subscribe` endpoint
15. [ ] Create `/api/push/unsubscribe` endpoint
16. [ ] Add notification toggle UI to settings/dashboard

### Phase 5: Sending Notifications
17. [ ] Implement `src/lib/push/send-notification.ts`
18. [ ] Integrate with Gmail webhook (send push for important emails)

### Phase 6: Testing
19. [ ] Test on iOS Safari (installed PWA)
20. [ ] Test on Android Chrome
21. [ ] Test on desktop browsers
22. [ ] Verify expired subscription cleanup (410 handling)

---

## iOS-Specific Considerations

1. **PWA Installation Required** - Push only works after "Add to Home Screen"
2. **User Gesture Required** - Must request permission from button click, not on page load
3. **VAPID Subject Validation** - Apple is strict; must be valid `mailto:` or `https://`
4. **Focus Mode** - Notifications respect user's Focus settings
5. **Badge API** - Can use `navigator.setAppBadge()` for unread counts

---

## Testing Locally

```bash
# HTTPS required for service workers and push
yarn dev --experimental-https

# Or use ngrok for mobile testing:
ngrok http 3000
```

iOS requires a real HTTPS certificate (not self-signed). Use ngrok or deploy to staging for iOS testing.

---

## Future Work

1. **Settings UI** - Give users a place to easily enable/disable notifications

---

## Sources

- [WebKit Blog - Web Push for iOS](https://webkit.org/blog/13878/web-push-for-web-apps-on-ios-and-ipados/)
- [MDN - Push API](https://developer.mozilla.org/en-US/docs/Web/API/Push_API)
- [Next.js PWA Guide](https://nextjs.org/docs/app/guides/progressive-web-apps)
- [web.dev - PWA Detection](https://web.dev/learn/pwa/detection)
- [PushForge README](https://github.com/draphy/pushforge/blob/master/packages/builder/README.md)
